<!-- widgets/photos.html -->
<!-- CHANGE SUMMARY: Incorporated proper theme handling pattern with early theme detection, structured logging, and standardized message handling following updated header.html example -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photos Widget</title>
  
  <!-- Import theme variables from parent -->
  <link rel="stylesheet" href="../../css/core/variables.css">
  
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      height: 100%;
      width: 100%;
      transition: background-color var(--transition-medium), color var(--transition-medium);
    }

    /* Photo container with theme support */
    #photo-container {
      width: 100%;      
      height: 100%;     
      background: var(--bg-primary);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color var(--transition-medium);
    }

    /* Loading state styling */
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-size: 1.2rem;
      text-align: center;
      transition: color var(--transition-medium);
    }

    .loading .status {
      margin-top: 10px;
      font-size: 2rem;
      animation: pulse 2s ease-in-out infinite alternate;
    }

    @keyframes pulse {
      from { opacity: 0.5; }
      to { opacity: 1.0; }
    }

    /* Photo styling with proper transitions */
    #photo-container img {
      position: absolute;
      top: var(--padding-widget, 10px);
      left: var(--padding-widget, 10px);
      right: var(--padding-widget, 10px);
      bottom: var(--padding-widget, 10px);
      width: calc(100% - calc(var(--padding-widget, 10px) * 2));
      height: calc(100% - calc(var(--padding-widget, 10px) * 2));
      object-fit: contain;
      object-position: center center;
      display: block;
      opacity: 1;
      transition: opacity var(--transition-medium), filter var(--transition-medium);
      border-radius: var(--border-radius-small, 4px);
    }

    #photo-container img.transitioning {
      opacity: 0;
    }

    /* Error state styling */
    .error-message {
      color: var(--color-error, #ff6b6b);
      text-align: center;
      padding: 20px;
      font-size: 1.1rem;
      transition: color var(--transition-medium);
    }

    /* Focus indicator for navigation */
    body.widget-focused #photo-container {
      outline: var(--outline-width-focused, 3px) solid var(--outline-focused, #00aaff);
      outline-offset: var(--outline-offset-widget, 0px);
      box-shadow: var(--glow-focused, 0 0 25px rgba(0, 170, 255, 0.9), 0 0 55px rgba(0, 170, 255, 0.5));
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      .loading {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div id="photo-container">
    <div class="loading" id="loading">
      Loading photos...
      <div class="status" id="status">â—‹</div>
    </div>
    
    <img id="photoImg" src="" alt="Slideshow Photo" style="display: none;">
  </div>
  
  <!-- Load config and photos data -->
  <script src="../../js/config.js"></script>
  <script src="./photos.js"></script>

  <script type="module">
    // Import logger for structured logging
    import { createLogger } from '../../js/utils/logger.js';
    const logger = createLogger('PhotosWidget');

    class PhotosWidget {
      constructor() {
        // Initialize widget state
        this.currentTheme = null;
        this.currentPhotoIndex = 0;
        this.shuffledPhotos = [];
        this.autoAdvanceInterval = null;
        this.transitionTime = 15; // Default 15 seconds
        this.isFocused = false;
        this.isTransitioning = false;
        
        // Get DOM elements
        this.photoImg = document.getElementById("photoImg");
        this.photoContainer = document.getElementById("photo-container");
        this.loadingDiv = document.getElementById("loading");
        
        this.init();
      }

      init() {
        // Apply early theme detection
        this.detectAndApplyInitialTheme();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Initialize photos
        this.initializePhotos();
        
        logger.info('Photos widget initialized with proper theme detection');
      }

      // Detect initial theme from DOM or localStorage (following header.html pattern)
      detectAndApplyInitialTheme() {
        let initialTheme = 'dark'; // fallback

        // Try to detect theme from body class (applied by early theme loading)
        if (document.body.classList.contains('theme-light')) {
          initialTheme = 'light';
        } else if (document.body.classList.contains('theme-dark')) {
          initialTheme = 'dark';
        } else {
          // Fallback: try localStorage
          try {
            const savedTheme = localStorage.getItem('dashie-theme');
            if (savedTheme && (savedTheme === 'dark' || savedTheme === 'light')) {
              initialTheme = savedTheme;
            }
          } catch (error) {
            logger.debug('Could not read theme from localStorage, using default');
          }
        }

        // Apply the detected theme immediately
        this.applyTheme(initialTheme);
        
        logger.info('Initial theme detected and applied', { theme: initialTheme });
      }

      setupEventListeners() {
        // Listen for widget-messenger communications
        window.addEventListener('message', (event) => {
          // Handle navigation commands (single action strings) - NEW PATTERN
          if (event.data && typeof event.data.action === 'string' && !event.data.type) {
            this.handleCommand(event.data.action);
          }
          
          // Handle data service messages (type objects)
          if (event.data && event.data.type) {
            this.handleDataServiceMessage(event.data);
          }
        });

        // Send widget ready signal
        window.addEventListener('load', () => {
          if (window.parent !== window) {
            window.parent.postMessage({ 
              type: 'widget-ready', 
              widget: 'photos' 
            }, '*');
          }
        });
      }

      // Apply theme to widget
      applyTheme(theme) {
        if (theme === this.currentTheme) {
          logger.debug('Theme already applied, skipping', { theme });
          return;
        }

        logger.info('Applying theme to photos widget', { 
          from: this.currentTheme, 
          to: theme 
        });

        this.currentTheme = theme;
        
        // Theme is automatically applied via CSS variables
        // Just ensure body has correct class for any theme-specific logic
        document.body.className = document.body.className.replace(/theme-\w+/, '');
        document.body.classList.add(`theme-${theme}`);
      }

      // --- Focus Management ---
      handleFocusChange(focused) {
        const wasFocused = this.isFocused;
        this.isFocused = focused;
        
        if (focused && !wasFocused) {
          // Widget gained focus - add focus indicator
          document.body.classList.add('widget-focused');
          logger.debug('Photos widget gained focus');
        } else if (!focused && wasFocused) {
          // Widget lost focus - remove focus indicator
          document.body.classList.remove('widget-focused');
          logger.debug('Photos widget lost focus');
        }
      }

      // --- Photo Management ---
      shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      showPhoto(index, smooth = true) {
        if (this.shuffledPhotos.length === 0) return;
        
        // Handle index wrapping
        if (index < 0) {
          this.currentPhotoIndex = this.shuffledPhotos.length - 1;
        } else if (index >= this.shuffledPhotos.length) {
          this.currentPhotoIndex = 0;
        } else {
          this.currentPhotoIndex = index;
        }

        // Prevent rapid transitions
        if (this.isTransitioning) return;
        this.isTransitioning = true;

        const newSrc = this.shuffledPhotos[this.currentPhotoIndex] + "?t=" + Date.now();
        
        if (smooth && this.photoImg.style.display !== 'none') {
          // Smooth transition
          this.photoImg.classList.add('transitioning');
          
          setTimeout(() => {
            this.photoImg.src = newSrc;
            this.photoImg.onload = () => {
              this.photoImg.classList.remove('transitioning');
              this.isTransitioning = false;
            };
            this.photoImg.onerror = () => {
              this.photoImg.classList.remove('transitioning');
              this.isTransitioning = false;
              this.handlePhotoError();
            };
          }, 150); // Half of transition time
        } else {
          // Immediate load (first photo)
          this.photoImg.src = newSrc;
          this.photoImg.onload = () => {
            this.loadingDiv.style.display = 'none';
            this.photoImg.style.display = 'block';
            this.isTransitioning = false;
          };
          this.photoImg.onerror = () => {
            this.isTransitioning = false;
            this.handlePhotoError();
          };
        }
        
        logger.debug('Showing photo', { 
          photoIndex: this.currentPhotoIndex + 1, 
          totalPhotos: this.shuffledPhotos.length 
        });
      }

      handlePhotoError() {
        logger.warn('Failed to load photo, skipping');
        if (this.shuffledPhotos.length > 1) {
          // Remove failed photo and try next
          this.shuffledPhotos.splice(this.currentPhotoIndex, 1);
          if (this.currentPhotoIndex >= this.shuffledPhotos.length) {
            this.currentPhotoIndex = 0;
          }
          this.showPhoto(this.currentPhotoIndex, false);
        } else {
          // Show error message
          this.loadingDiv.innerHTML = '<div class="error-message">No photos available</div>';
        }
      }

      nextPhoto() {
        this.showPhoto(this.currentPhotoIndex + 1);
      }

      prevPhoto() {
        this.showPhoto(this.currentPhotoIndex - 1);
      }

      updateTransitionTime(newTime) {
        if (newTime && newTime >= 5 && newTime <= 120) {
          this.transitionTime = newTime;
          logger.info('Updated transition time', { transitionTime: this.transitionTime });
          
          // Restart auto-advance with new timing
          if (this.autoAdvanceInterval) {
            clearInterval(this.autoAdvanceInterval);
            this.startAutoAdvance();
          }
        }
      }

      startAutoAdvance() {
        if (this.autoAdvanceInterval) {
          clearInterval(this.autoAdvanceInterval);
        }
        this.autoAdvanceInterval = setInterval(() => {
          this.nextPhoto();
        }, this.transitionTime * 1000);
        logger.info('Auto-advance started', { intervalSeconds: this.transitionTime });
      }

      stopAutoAdvance() {
        if (this.autoAdvanceInterval) {
          clearInterval(this.autoAdvanceInterval);
          this.autoAdvanceInterval = null;
          logger.info('Auto-advance stopped');
        }
      }

      // --- Command Handling with Focus Management ---
      handleCommand(action) {
        logger.debug('Photos widget received command', { action });
        
        // AUTO-FOCUS: Detect focus from receiving commands
        if (!this.isFocused) {
          this.handleFocusChange(true);
        }
        
        switch(action) {
          case 'right':
          case 'down':
            this.nextPhoto();
            break;
          case 'left':
          case 'up':
            this.prevPhoto();
            break;
          case 'select':
            logger.debug('Enter pressed on photos widget');
            break;
          case 'back':
            // CRITICAL: Handle focus loss
            if (this.isFocused) {
              this.handleFocusChange(false);
            }
            break;
          default:
            logger.debug('Photos widget ignoring command', { action });
            break;
        }
      }

      // --- System Message Handling ---
      handleDataServiceMessage(data) {
        logger.debug('Photos widget received system message', { type: data.type });
        
        switch(data.type) {
          case 'widget-update':
            if (data.action === 'state-update' && data.payload) {
              // Handle photos data updates if needed
              if (data.payload.photos) {
                logger.debug('Processing photos data update');
                // Could refresh photos here if needed
              }
              
              // Handle theme updates
              if (data.payload.theme && data.payload.theme !== this.currentTheme) {
                this.applyTheme(data.payload.theme);
              }
            }
            break;
            
          case 'theme-change':
            this.applyTheme(data.theme);
            break;
            
          case 'update-settings':
            if (data.photoTransitionTime) {
              this.updateTransitionTime(data.photoTransitionTime);
            }
            break;
            
          default:
            logger.debug('Unhandled system message type', { type: data.type });
            break;
        }
      }

      // --- Initialize Photos ---
      initializePhotos() {
        // Check if photos data is available
        if (typeof photos === 'undefined' || !Array.isArray(photos) || photos.length === 0) {
          logger.warn('No photos data available, showing placeholder');
          this.loadingDiv.innerHTML = '<div class="error-message">No photos configured</div>';
          return;
        }

        this.shuffledPhotos = this.shuffleArray(photos);
        this.showPhoto(0, false); // First photo without smooth transition
        
        // Start auto-advance after a delay
        setTimeout(() => {
          this.startAutoAdvance();
        }, 1000);
        
        logger.info('Photos widget initialized', { 
          totalPhotos: this.shuffledPhotos.length,
          transitionTime: this.transitionTime 
        });
      }
    }

    // Initialize the widget when DOM is ready
    document.addEventListener("DOMContentLoaded", function() {
      new PhotosWidget();
    });
  </script>
</body>
</html>