<!-- Photos-settings.html -->
<!-- CHANGE SUMMARY: Fixed progress callbacks, settings save, stay on upload screen, add +Create Album option -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photos Settings</title>
  <link rel="stylesheet" href="photos-settings.css">
</head>
<body>
  <div class="modal-container">
    <div class="modal-header">
      <button class="back-button" id="back-button" style="visibility: visible;">‹ Settings</button>
      <h2 id="modal-title">Photos</h2>
      <button class="close-button" id="close-button">×</button>
    </div>
    
    <div class="modal-body">
      <div id="error-container"></div>

      <!-- Main Photos Screen -->
      <div class="screen active" id="main-screen">
        <!-- Photo Stats Box -->
        <div class="photo-stats-box">
          <div class="photo-stat-row">
            <span class="photo-stat-label">Photos</span>
            <span class="photo-stat-value" id="photo-count">Loading...</span>
          </div>
          <div class="photo-stat-row">
            <span class="photo-stat-label">Albums</span>
            <span class="photo-stat-value" id="album-count">Loading...</span>
          </div>
          <div class="photo-stat-row">
            <span class="photo-stat-label">Storage</span>
            <span class="photo-stat-value" id="storage-used">Loading...</span>
          </div>
          <div class="storage-bar">
            <div class="storage-bar-fill" id="storage-bar-fill"></div>
          </div>
        </div>

        <!-- Main Menu -->
        <div class="settings-section">
          <div class="settings-cell" id="add-photos-menu" tabindex="0">
            <span class="cell-label">Add Photos</span>
            <span class="cell-chevron">›</span>
          </div>
          <div class="settings-cell" id="delete-photos-menu" tabindex="0">
            <span class="cell-label">Delete Photos</span>
            <span class="cell-chevron">›</span>
          </div>
          <div class="settings-cell" id="display-album-menu" tabindex="0">
            <span class="cell-label">Choose Display Album</span>
            <span class="cell-value" id="display-album-value">All Photos</span>
            <span class="cell-chevron">›</span>
          </div>
          <div class="settings-cell" id="transition-menu" tabindex="0">
            <span class="cell-label">Photo Transition</span>
            <span class="cell-value" id="transition-value">5 seconds</span>
            <span class="cell-chevron">›</span>
          </div>
        </div>
      </div>

      <!-- Choose Upload Album Screen -->
      <div class="screen" id="choose-upload-album-screen">
        <div class="settings-section">
          <!-- Add Album option at top -->
          <div class="settings-cell" id="create-album-cell" tabindex="0" style="border-bottom: 0.5px solid rgba(60, 60, 67, 0.36);">
            <span class="cell-label" style="font-weight: 600;">+ Create Album</span>
            <span class="cell-chevron">›</span>
          </div>
        </div>
        <div class="settings-section" id="upload-album-selection-list">
          <!-- Albums populated dynamically -->
        </div>

        <!-- Upload Progress - stays on this screen -->
        <div class="progress-section" id="upload-progress-section" style="display: none;">
          <div class="progress-info" id="upload-progress-info">Uploading...</div>
          <div class="progress-bar">
            <div class="progress-fill" id="upload-progress-fill"></div>
          </div>
          <div class="progress-detail" id="upload-progress-detail">0 / 0 files</div>
        </div>
      </div>

      <!-- Delete Photos Screen -->
      <div class="screen" id="delete-photos-screen">
        <div class="settings-section">
          <p style="padding: 16px; text-align: center; color: #8e8e93;">
            Delete functionality coming soon
          </p>
        </div>
      </div>

      <!-- Display Album Screen -->
      <div class="screen" id="display-album-screen">
        <div class="settings-section" id="album-selection-list">
          <!-- Albums populated dynamically -->
        </div>
      </div>

      <!-- Photo Transition Screen -->
      <div class="screen" id="transition-screen">
        <div class="settings-section">
          <div class="settings-cell selectable" data-value="3" tabindex="0">
            <span class="cell-label">3 seconds</span>
            <span class="cell-checkmark">✓</span>
          </div>
          <div class="settings-cell selectable" data-value="5" tabindex="0">
            <span class="cell-label">5 seconds</span>
            <span class="cell-checkmark">✓</span>
          </div>
          <div class="settings-cell selectable" data-value="10" tabindex="0">
            <span class="cell-label">10 seconds</span>
            <span class="cell-checkmark">✓</span>
          </div>
          <div class="settings-cell selectable" data-value="30" tabindex="0">
            <span class="cell-label">30 seconds</span>
            <span class="cell-checkmark">✓</span>
          </div>
        </div>
      </div>
      
      <!-- Hidden file input -->
      <input type="file" id="file-input" accept="image/*" multiple style="display: none;">
    </div>
  </div>

  <script type="module">
    import { createLogger } from '../../js/utils/logger.js';
    import { PhotoStorageService } from '../../js/supabase/photo-storage-service.js';

    const logger = createLogger('PhotosSettingsModal');

    class PhotosSettingsModal {
      constructor() {
        this.storage = null;
        this.userId = null;
        this.currentSettings = {};
        this.navigationStack = ['main-screen'];
        this.currentFocusIndex = 0;
        this.focusableElements = [];
        this.pendingUploadAlbum = null;
        
        this.backBtn = document.getElementById('back-button');
        this.closeBtn = document.getElementById('close-button');
        this.modalTitle = document.getElementById('modal-title');
        this.errorContainer = document.getElementById('error-container');
        
        logger.info('PhotosSettingsModal initializing');
        this.setupEventListeners();
        this.signalReady();
      }

      signalReady() {
        logger.debug('Signaling modal ready to parent');
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'photos-modal-ready'
          }, '*');
        }
      }

      setupEventListeners() {
        // Back button
        this.backBtn.addEventListener('click', () => this.handleBack());
        
        // Close button
        this.closeBtn.addEventListener('click', () => this.close());

        // Listen for initialization from parent
        window.addEventListener('message', (event) => {
          if (event.data?.type === 'init-photos-modal') {
            this.initialize(event.data.userId, event.data.theme, event.data.settings);
          }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => this.handleKeydown(e));

        // Main menu navigation
        document.getElementById('add-photos-menu').addEventListener('click', () => {
          this.navigateTo('choose-upload-album-screen', 'Choose Album');
        });
        
        document.getElementById('delete-photos-menu').addEventListener('click', () => {
          this.navigateTo('delete-photos-screen', 'Delete Photos');
        });
        
        document.getElementById('display-album-menu').addEventListener('click', () => {
          this.navigateTo('display-album-screen', 'Choose Display Album');
        });
        
        document.getElementById('transition-menu').addEventListener('click', () => {
          this.navigateTo('transition-screen', 'Photo Transition');
        });

        // Create album button
        document.getElementById('create-album-cell').addEventListener('click', () => {
          this.handleCreateAlbum();
        });

        // File input handler
        document.getElementById('file-input').addEventListener('change', (e) => {
          this.handleFileSelection(e);
        });

        // Selection handlers for transition time
        document.querySelectorAll('#transition-screen .selectable').forEach(cell => {
          cell.addEventListener('click', () => this.handleTransitionSelection(cell));
        });

        logger.debug('Event listeners attached');
      }

      handleKeydown(e) {
        const keyMap = {
          'ArrowUp': 'up',
          'ArrowDown': 'down',
          'Enter': 'enter',
          'Escape': 'escape',
          'Backspace': 'back'
        };

        const action = keyMap[e.key];
        if (!action) return;

        e.preventDefault();
        e.stopPropagation();

        switch (action) {
          case 'up':
            this.moveFocus(-1);
            break;
          case 'down':
            this.moveFocus(1);
            break;
          case 'enter':
            this.activateCurrentElement();
            break;
          case 'escape':
          case 'back':
            this.handleBack();
            break;
        }
      }

      updateFocusableElements() {
        const currentScreen = document.querySelector('.screen.active');
        if (!currentScreen) return;

        this.focusableElements = Array.from(
          currentScreen.querySelectorAll('.settings-cell')
        );
        
        const currentScreenId = this.getCurrentScreen();
        if (currentScreenId === 'transition-screen') {
          const selectedIndex = this.focusableElements.findIndex(el => el.classList.contains('selected'));
          if (selectedIndex !== -1) {
            this.currentFocusIndex = selectedIndex;
          }
        } else if (currentScreenId === 'display-album-screen') {
          const selectedIndex = this.focusableElements.findIndex(el => el.classList.contains('selected'));
          if (selectedIndex !== -1) {
            this.currentFocusIndex = selectedIndex;
          }
        } else {
          this.currentFocusIndex = 0;
        }

        this.updateFocus();
      }

      moveFocus(direction) {
        if (this.focusableElements.length === 0) return;

        if (this.focusableElements[this.currentFocusIndex]) {
          this.focusableElements[this.currentFocusIndex].classList.remove('focused');
        }

        this.currentFocusIndex += direction;

        if (this.currentFocusIndex < 0) {
          this.currentFocusIndex = this.focusableElements.length - 1;
        } else if (this.currentFocusIndex >= this.focusableElements.length) {
          this.currentFocusIndex = 0;
        }

        this.updateFocus();
      }

      updateFocus() {
        this.focusableElements.forEach(el => {
          el.blur();
          el.classList.remove('focused');
        });

        if (this.focusableElements[this.currentFocusIndex]) {
          this.focusableElements[this.currentFocusIndex].focus();
          this.focusableElements[this.currentFocusIndex].classList.add('focused');
        }
      }

      activateCurrentElement() {
        const current = this.focusableElements[this.currentFocusIndex];
        if (current) {
          logger.debug('Activating element via Enter', { 
            id: current.id,
            classList: Array.from(current.classList)
          });
          current.click();
        }
      }

      handleBack() {
        const isMainScreen = this.getCurrentScreen() === 'main-screen';
        
        if (isMainScreen) {
          this.close();
        } else {
          this.navigateBack();
        }
      }

      navigateTo(screenId, title) {
        const currentScreen = document.querySelector('.screen.active');
        const nextScreen = document.getElementById(screenId);
        
        if (!nextScreen) {
          logger.error('Screen not found', { screenId });
          return;
        }

        this.navigationStack.push(screenId);
        this.currentFocusIndex = 0;

        currentScreen.classList.remove('active');
        nextScreen.classList.add('active');

        this.modalTitle.textContent = title;
        this.updateBackButton();
        this.updateFocusableElements();

        logger.debug('Navigated to screen', { screenId, title });
      }

      navigateBack() {
        if (this.navigationStack.length <= 1) return;

        this.navigationStack.pop();
        const previousScreenId = this.navigationStack[this.navigationStack.length - 1];
        
        const currentScreen = document.querySelector('.screen.active');
        const previousScreen = document.getElementById(previousScreenId);

        if (!previousScreen) return;

        this.currentFocusIndex = 0;
        currentScreen.classList.remove('active');
        previousScreen.classList.add('active');

        const title = previousScreenId === 'main-screen' ? 'Photos' : this.modalTitle.textContent;
        this.modalTitle.textContent = title;
        this.updateBackButton();
        this.updateFocusableElements();

        logger.debug('Navigated back to', { screenId: previousScreenId });
      }

      getCurrentScreen() {
        return this.navigationStack[this.navigationStack.length - 1];
      }

      updateBackButton() {
        const isMainScreen = this.getCurrentScreen() === 'main-screen';
        
        if (isMainScreen) {
          this.backBtn.textContent = '‹ Settings';
        } else {
          this.backBtn.textContent = '‹ Photos';
        }
      }

      handleTransitionSelection(cell) {
        const value = parseInt(cell.dataset.value);
        
        document.querySelectorAll('#transition-screen .selectable').forEach(c => {
          c.classList.remove('selected');
          c.querySelector('.cell-checkmark').style.visibility = 'hidden';
        });

        cell.classList.add('selected');
        cell.querySelector('.cell-checkmark').style.visibility = 'visible';

        document.getElementById('transition-value').textContent = `${value} seconds`;

        this.saveSettingToParent('photos.transitionTime', value);

        logger.info('Transition time selected', { value });
      }

      async handleAlbumSelection(albumName, isUpload = false) {
        if (isUpload) {
          this.pendingUploadAlbum = albumName;
          logger.info('Album selected for upload', { album: albumName });
          
          document.getElementById('file-input').click();
          
        } else {
          document.querySelectorAll('#album-selection-list .selectable').forEach(c => {
            c.classList.remove('selected');
            c.querySelector('.cell-checkmark').style.visibility = 'hidden';
          });

          const selectedCell = document.querySelector(`#album-selection-list [data-album="${albumName}"]`);
          if (selectedCell) {
            selectedCell.classList.add('selected');
            selectedCell.querySelector('.cell-checkmark').style.visibility = 'visible';
          }

          const displayName = albumName === 'all-photos' ? 'All Photos' : albumName;
          document.getElementById('display-album-value').textContent = displayName;

          this.saveSettingToParent('photos.source', albumName);

          logger.info('Display album selected', { album: albumName });
        }
      }

      async handleCreateAlbum() {
        const albumName = prompt('Enter new album name:');
        
        if (!albumName || albumName.trim() === '') {
          return;
        }
        
        const sanitized = albumName.trim().toLowerCase().replace(/[^a-z0-9-]/g, '-');
        
        if (sanitized === 'all-photos') {
          alert('Album name "all-photos" is reserved. Please choose another name.');
          return;
        }

        try {
          await this.storage.createFolder(sanitized);
          logger.info('Album created', { name: sanitized });
          
          await this.loadAlbums();
          
          alert(`Album "${sanitized}" created successfully!`);
        } catch (error) {
          logger.error('Failed to create album', error);
          this.showError('Failed to create album: ' + error.message);
        }
      }

saveSettingToParent(path, value) {
  const keys = path.split('.');
  let obj = this.currentSettings;
  for (let i = 0; i < keys.length - 1; i++) {
    if (!obj[keys[i]]) obj[keys[i]] = {};
    obj = obj[keys[i]];
  }
  obj[keys[keys.length - 1]] = value;

  logger.info('Saving setting to parent', { path, value });

  if (window.parent !== window) {
    // CHANGED: Use setSetting instead of updateSetting
    const settingsInstance = window.parent.settingsInstance;
    if (settingsInstance && settingsInstance.controller) {
      try {
        const controller = settingsInstance.controller;
        // Use setSetting which exists in SettingsController
        if (typeof controller.setSetting === 'function') {
          controller.setSetting(path, value);
          controller.saveSettings(); // Also trigger save
          logger.success('Setting saved via settingsInstance.controller.setSetting');
          return;
        }
      } catch (error) {
        logger.warn('settingsInstance.controller.setSetting failed', error);
      }
    }
    
    // Fallback: try postMessage
    window.parent.postMessage({
      type: 'update-setting',
      path: path,
      value: value
    }, '*');
    logger.info('Setting sent via postMessage fallback');
  }
}

      async initialize(userId, theme, settings = {}) {
        this.userId = userId;
        this.currentSettings = settings;
        
        if (!this.userId) {
          this.showError('User ID not provided');
          return;
        }

        logger.info('Initializing', { userId: this.userId });

        const jwtService = window.parent?.jwtAuth;
        
        try {
          this.storage = new PhotoStorageService(this.userId, jwtService);
          
          if (theme) {
            this.applyTheme(theme);
          }

          await this.loadPhotoStats();
          await this.loadAlbums();
          this.populateCurrentSettings();
          this.updateFocusableElements();
          
          logger.success('Modal initialized successfully');
        } catch (error) {
          this.showError('Failed to initialize: ' + error.message);
          logger.error('Initialization failed', error);
        }
      }

      async loadPhotoStats() {
        try {
          const usage = await this.storage.getStorageUsage();
          const folders = await this.storage.listFolders();
          const allPhotos = await this.storage.listPhotos(null, 1000);
          
          document.getElementById('photo-count').textContent = allPhotos.length;
          document.getElementById('album-count').textContent = folders.length;
          document.getElementById('storage-used').textContent = `${usage.usedMB} MB / ${usage.quotaMB} MB`;
          document.getElementById('storage-bar-fill').style.width = `${usage.percentUsed}%`;
          
          logger.debug('Photo stats loaded');
        } catch (error) {
          logger.error('Failed to load photo stats', error);
        }
      }

      async loadAlbums() {
        try {
          const folders = await this.storage.listFolders();
          
          const albumList = document.getElementById('album-selection-list');
          albumList.innerHTML = '';
          
          folders.forEach(folder => {
            const cell = document.createElement('div');
            cell.className = 'settings-cell selectable';
            cell.dataset.album = folder.name;
            cell.tabIndex = 0;
            cell.innerHTML = `
              <span class="cell-label">${folder.name === 'all-photos' ? 'All Photos' : folder.name}</span>
              <span class="cell-checkmark">✓</span>
            `;
            cell.addEventListener('click', () => this.handleAlbumSelection(folder.name, false));
            albumList.appendChild(cell);
          });

          const uploadAlbumList = document.getElementById('upload-album-selection-list');
          uploadAlbumList.innerHTML = '';
          
          folders.forEach(folder => {
            const cell = document.createElement('div');
            cell.className = 'settings-cell selectable';
            cell.dataset.album = folder.name;
            cell.tabIndex = 0;
            cell.innerHTML = `
              <span class="cell-label">${folder.name === 'all-photos' ? 'All Photos' : folder.name}</span>
              <span class="cell-chevron">›</span>
            `;
            cell.addEventListener('click', () => this.handleAlbumSelection(folder.name, true));
            uploadAlbumList.appendChild(cell);
          });
          
          logger.debug('Albums loaded', { count: folders.length });
        } catch (error) {
          logger.error('Failed to load albums', error);
        }
      }

      populateCurrentSettings() {
        const transitionTime = this.currentSettings.photos?.transitionTime || 5;
        document.querySelectorAll('#transition-screen .selectable').forEach(cell => {
          const value = parseInt(cell.dataset.value);
          if (value === transitionTime) {
            cell.classList.add('selected');
            cell.querySelector('.cell-checkmark').style.visibility = 'visible';
          } else {
            cell.classList.remove('selected');
            cell.querySelector('.cell-checkmark').style.visibility = 'hidden';
          }
        });
        document.getElementById('transition-value').textContent = `${transitionTime} seconds`;

        const source = this.currentSettings.photos?.source || 'all-photos';
        const displayName = source === 'all-photos' ? 'All Photos' : source;
        document.getElementById('display-album-value').textContent = displayName;
        
        document.querySelectorAll('#album-selection-list .selectable').forEach(cell => {
          if (cell.dataset.album === source) {
            cell.classList.add('selected');
            cell.querySelector('.cell-checkmark').style.visibility = 'visible';
          } else {
            cell.classList.remove('selected');
            cell.querySelector('.cell-checkmark').style.visibility = 'hidden';
          }
        });
      }

      async handleFileSelection(event) {
        const files = event.target.files;
        if (!files || files.length === 0) return;

        const targetAlbum = this.pendingUploadAlbum || 'all-photos';
        logger.info('Files selected for upload', { count: files.length, album: targetAlbum });

        const progressSection = document.getElementById('upload-progress-section');
        const progressInfo = document.getElementById('upload-progress-info');
        const progressFill = document.getElementById('upload-progress-fill');
        const progressDetail = document.getElementById('upload-progress-detail');

        progressSection.style.display = 'block';
        progressInfo.textContent = 'Preparing upload...';
        progressFill.style.width = '0%';
        progressDetail.textContent = `0 / ${files.length} files`;

        try {
          const results = await this.storage.uploadPhotos(files, targetAlbum, (percent, filename, current, total) => {
            logger.debug('Upload progress', { percent, current, total, filename });
            
            progressFill.style.width = `${percent}%`;
            progressDetail.textContent = `${current} / ${total} files`;
            progressInfo.textContent = `Uploading ${filename}...`;
          });

          const successful = results.filter(r => r.success).length;
          
          logger.info('Upload complete', { successful, total: files.length });
          
          if (successful === files.length) {
            progressInfo.textContent = 'Upload complete!';
            progressFill.style.width = '100%';
            
            if (window.parent !== window) {
              window.parent.postMessage({
                type: 'photos-uploaded'
              }, '*');
            }
          } else {
            progressInfo.textContent = `${successful} of ${files.length} photos uploaded`;
          }

          await this.loadPhotoStats();

          setTimeout(() => {
            progressSection.style.display = 'none';
            progressFill.style.width = '0%';
          }, 2000);

          event.target.value = '';
          this.pendingUploadAlbum = null;

        } catch (error) {
          logger.error('Upload failed', error);
          progressInfo.textContent = 'Upload failed: ' + error.message;
          this.showError(error.message);
          this.pendingUploadAlbum = null;
        }
      }

      applyTheme(theme) {
        if (theme === 'dark') {
          document.body.classList.add('theme-dark');
        } else {
          document.body.classList.remove('theme-dark');
        }
      }

      showError(message) {
        this.errorContainer.innerHTML = `
          <div class="error-message">${message}</div>
        `;
        setTimeout(() => {
          this.errorContainer.innerHTML = '';
        }, 5000);
      }

      close() {
        logger.info('Closing modal');
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'close-photos-modal'
          }, '*');
        }
      }
    }

    const modal = new PhotosSettingsModal();
  </script>
</body>
</html>